<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>.Net中的接口, 抽象, 密封与继承</title>
    <link rel="icon" href="../../../Source/icon-img.jpeg">
    <link rel="stylesheet" href="../../../CSS/ArticleDetail.css">
    <link rel="stylesheet" href="../../../Vendor/bootstrap-3.3.7-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>

<div class="labels">

    <span class="label label-primary">抽象类与抽象方法</span>
    <span class="label label-warning">Interface</span>
    <span class="label label-info">密封类与密封方法</span>
    <span class="label label-success">继承</span>

</div>

<div class="contentBgDiv">

    <p class="title">.Net中的接口, 抽象, 密封与继承</p>
    <hr>

    <p class="introduceText">
        C#中的接口就是我们经常听到的API函数, API:Application Programming Interface, 即应用程序接口;
    </p>

    <p class="smallTitle">一、接口的声明</p>
    <div class="codeAero">
        <p>
            接口：可属于任何类或结构的一组相关功能；<br>
            接口成员：可以是自动属性，方法，事件，索引器， 不能包含常数、字段、运算符、实力构造器、析构函数或类型、也不能
            包含任何种类的静态成员； 接口中成员名称不能一致，即使是两种不能的类型；<br>
            格式：习惯以大写的I开头+具体的接口功能命名；<br>
            声明：可以在类内部声明， 但是一般新建一个新的接口项， 接口默认声明为public, 不允许有访问修饰符
            （类默认声明为prviate）; 由于接口中不能有字段， 所以属性被写作自动属性; string Name {get; set;};
            接口中的方法不能包含方法体；<br>

        </p>
    </div>

    <p class="smallTitle">二、接口的实现和继承</p>
    <div class="codeAero">
        <p>
            1.实现过程必须在实现接口的类中完成；<br>
            2.类继承具有单根性，接口可多重继承；<br>
            3.父接口也成为该接口的显式基接口；<br>
            4.接口多重继承时，派生接口名与父接口用冒号隔开，多个父接口之间用逗号隔开；<br>
            5.如果派生接口对父接口的成员进行重定义时，需要使用new来进行声明；<br>
            6.接口的设计应该符合开放封闭性原则：软件实体可以扩展，但是不可以修改；<br>
            7.接口的实现：可以隐式实现（用接口来接受类的实例类型，然后进行调用）; 可以显式实现（直接用类的实例调用接口方法）;<br>
        </p>
    </div>

    <p class="smallTitle">三、 抽象类与抽象方法</p>
    <div class="codeAero">

        <p>
            抽象方法使用abstract来修饰:<br>
            public abstract void hehe();
        </p>
        <p>
            1.抽象方法不能含有方法体；<br>
            2.抽象类不能实例化，必须通过继承由派生类实现其抽象方法，因此不能new；也不能使用static，private，或者virtual修饰符<br>
            3.抽象类的声明就是为了实现派生或继承，所以我们不能将它标记为sealed;<br>
            4.如果派生类没有实现所有的抽象方法，则该派生类也必须声明为抽象类；反之，如果要将派生类声明为非抽象类，
            则必须实现父抽象类的所有抽象方法；<br>
            5.抽象方法必须声明在抽象类中；<br>
            6.重写抽象方法采用override；<br>
            7.abstract方法与虚方法virtual的区别：抽象方法没有自己的实现、虚方法有自己的实现、两者都可以通过override来进行重写；<br>
        </p>

    </div>

    <p class="smallTitle">四、 密封类与密封方法</p>
    <div class="codeAero">

        <p>
            1.并不是所有的类都能被继承， 不能继承的类成为密封类， 用关键词sealed；<br>
            2.使用场合：重写某些功能可能会引起编译错误、商业原因等；<br>
            3.虚方法virtual和抽象方法abstract的存在就是为了派生和继承，因此不能使用sealed；<br>
            4..NET基类库大量使用了密封类，比如string；<br>
            5.继承时父类的修饰符范围应该大于派生类；<br>
        </p>
    </div>


    <br><br>

</div>

</body>
</html>