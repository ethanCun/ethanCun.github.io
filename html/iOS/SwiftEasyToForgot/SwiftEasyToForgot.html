<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Swift那些搞过却又容易忘记的东东</title>
    <link rel="icon" href="../../../Source/icon-img.jpeg">
    <link rel="stylesheet" href="../../../CSS/ArticleDetail.css">
    <link rel="stylesheet" href="../../../Vendor/bootstrap-3.3.7-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>

<div class="labels">

    <span class="label label-success">swiftSwift那些搞过却又容易忘记的东东</span>
</div>

<div class="contentBgDiv">
    <p class="title">Swift那些搞过却又容易忘记的东东</p>
    <hr>

    <ul>
        <li><a href="#mark">swift中的mark</a> </li>
        <li><a href="#swift">swift 调用oc库</a> </li>
        <li><a href="#swiftInOc">oc工程使用swift库</a></li>
        <li><a href="#try">call can throw but is mot marked with try...</a> </li>
        <li><a href="#ocInSwift">swift项目中使用oc框架不提示方法</a> </li>
        <li><a href="#stringTransfer">关于变量类型</a> </li>
        <li><a href="#class">获取对象类型</a> </li>
        <li><a href="#after">swift的延时操作</a> </li>
        <li><a href="#mean">$0、$1的实际含义</a> </li>
        <li><a href="#lazy">swift中的数组与懒加载</a> </li>
        <li><a href="#error1">Property 'self.backgroundLabBgColor' not initialized at super.init - Delegate</a> </li>
        <li><a href="#objc">@objc,@nonobjc与@objcMembers</a> </li>
        <li><a href="#closure">swift中的闭包</a> </li>
        <li><a href="#setget">swift中的set与get</a> </li>
    </ul>

    <p class="smallTitle" id="swift"><b>swift 调用oc库</b></p>


    <p class="contents">
        1.、swift工程里新建Header file, 名称：项目名称-Bridging-Header.h
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-28538c944470898a.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-28538c944470898a.png?imageMogr2/auto-orient/strip"></a>

    <p class="contents">
        2、设置路径 target -> building settings -> swift compiler -> objective-c bridging header
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-219154da7df8daaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-219154da7df8daaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg"></a>


    <p class="contents">
        3、导入库 注意导入方式
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-cacc0ac39568debc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-cacc0ac39568debc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"></a>

    <p class="smallTitle" id="swiftInOc"><b>oc工程使用swift库</b></p>

    <br>

    <p class="contents">
        在需要使用的地方添加：项目名称-Swift.h
    </p>
    <p class="contents">如果oc中调用不了swift方法,请在前面加上@objc</p>
    <p class="contents">原因:</p>
    <pre>
            Objective-C和Swift在底层使用的是两套完全不同的机制，Cocoa中的Objective-C对象是基于运行时的，
        它从骨子里遵循了KVC（Key-Value Coding，通过类似字典的方式存储对象信息）以及动态派发
        （Dynamic Dispatch，在运行调用时再决定实际调用的具体实现）。

            而Swift为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。
        也就是说，Swift类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，
        而可以直接使用。

            显而易见，这带来的问题是如果我们要使用Objective-C的代码或者特性来调用纯Swift的类型时候，
        我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在Swift类型文件中，
        我们可以将需要暴露给Objective-C使用的任何地方（包括类，属性和方法等）的声明前面加上
        @objc修饰符。注意这个步骤只需要对那些不是继承自NSObject的类型进行，
        如果你用Swift写的class是继承自NSObject的话，Swift会默认自动为所有的非private的类和成员加上@objc。
        这就是说，对一个NSObject的子类，你只需要导入相应的头文件就可以在Objective-C里使用这个类了。

            添加@objc修饰符并不意味着这个方法或者属性会变成动态派发，Swift依然可能会将其优化为静态调用。
        如果你需要和Objective-C里动态调用时相同的运行时特性的话，你需要使用的修饰符是dynamic。
        一般情况下在做App开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的
        "黑魔法" 的时候，我们就需要用到dynamic修饰符了。
    </pre>

    <p class="contents" id="objc"><b>@objc,@nonobjc,@objcMembers</b></p>
    <pre>
          1，过去的情况（Swift3）
        （1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。
            在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。
        （2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。
        class MyClass: NSObject {
            func print() { } // 包含隐式的 @objc
            func show() { } // 包含隐式的 @objc
        }
        （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。

        2，现在的情况（Swift4）
        （1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况：
            覆盖父类的 Objective-C 方法
            符合一个 Objective-C 的协议

        （2）大多数地方必须手工显示地加上 @objc。
        class MyClass: NSObject {
            @objc func print() { } //显示的加上 @objc
            @objc func show() { } //显示的加上 @objc
        }

        （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。
        @objcMembers
        class MyClass: NSObject {
            func print() { } //包含隐式的 @objc
            func show() { } //包含隐式的 @objc
        }

        extension MyClass {
            func baz() { } //包含隐式的 @objc
        }

        （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。
        class SwiftClass { }

        @objc extension SwiftClass {
            func foo() { } //包含隐式的 @objc
            func bar() { } //包含隐式的 @objc
        }

        （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。
        @objcMembers
        class MyClass : NSObject {
            func wibble() { } //包含隐式的 @objc
        }

        @nonobjc extension MyClass {
            func wobble() { } //不会包含隐式的 @objc
        }

    </pre>

    <p class="smallTitle" id="try"><b>call can throw but is mot marked with try...</b></p>

    <br>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-74e7b9d11c100885.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-74e7b9d11c100885.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">错误示意图1</p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-5d55359915853406.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-5d55359915853406.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">没有使用try.png</p>

    <p class="contents">
        <b>解决:</b>
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-272f9efe48bb346a.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-272f9efe48bb346a.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">do catch+try.png</p>

    <p class="smallTitle" id="ocInSwift"><b>swift项目中使用oc框架不提示方法</b></p>

    <br>

    <p class="contents">
        在swift工程中使用oc框架时：正确在项目名-Bridging-Header里导入了框架，
        如#import &lt;KissXML/KissXML.h&gt;,#import &lt;XMLReader/XMLReader.h&gt;还是不提示方法，
        可以这样：
    </p>

    <div class="codeAero">

        <p class="contents">
            1.第一步首先删除 此目录下的这个文件夹：~/Library/Developer/Xcode/DerivedData<br><br>

            2.重启xcode试试，如果还不提示，删除此目录下的这个文件：~/Library/Caches/com.apple.dt.Xcode<br><br>

            3.重新运行xcode就好了<br><br>
        </p>
    </div>

    <p class="contents">
        如果还是没用：在使用的地方再导入一次，如：import XMLReader
    </p>

    <p class="smallTitle" id="stringTransfer"><b>关于变量类型</b></p>

    <br>

    <p class="contents">
        Striing -》int 需要使用NSString来过渡，toInt不行了 注意变量的类型可以很大程度提高编译速度 特别是类似a/b/c
    </p>

    <p class="contents">
        如：<br>
        print(NSStrinwg(string:s).intValue+1)<br>
    </p>

    <p class="smallTitle" id="class"><b>获取对象类型</b></p>
    <pre>
        object_getClass(&lt;#T##obj: AnyObject!##AnyObject!#&gt;)
        tableView.register(object_getClass(UITableViewCell()), forCellReuseIdentifier: "hehe")
    </pre>

    <p class="smallTitle" id="after"><b>swift的延时操作</b></p>
    <pre>
        //延时1秒执行
        let time: TimeInterval = 1.0
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {
          //code
          print("1 秒后输出")
        }
    </pre>

    <p class="smallTitle" id="mean"><b>$0、$1的实际含义</b></p>
    <p class="contents">
        swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：
    </p>
    <pre>
        let nums = [3,7,90,1,2,3,4,5,6,7]

        let sortNums = nums.sorted(by: { (a, b) -> Bool in

            return a < b
        })

        let sortNums2 = nums.sorted(by: {$0 < $1})

        print("sortNums = \(sortNums)\nsortNums2=\(sortNums2)")
    </pre>
    <p class="contents">
        输出结果:
    </p>
    <pre>
        sortNums = [1, 2, 3, 3, 4, 5, 6, 7, 7, 90]
        sortNums2=[1, 2, 3, 3, 4, 5, 6, 7, 7, 90]
    </pre>

    <p class="smallTitle" id="mark"><b>swift中的mark</b></p>
    <pre>
        oc:#pragma mark -说明文字
        swift:  // MARK: - 说明文字,带分割线
                // MARK: 说明文字,不带分割线
    </pre>

    <p class="smallTitle" id="lazy"><b>swift中的数组与懒加载</b></p>
    <p class="contents">
        使用let修饰的数组是不可变数组:let array2 : [NSObject] = ["age", 18]<br>
        使用var修饰的数组是可变数组:var array1 : [String] = [String]()
    </p>
    <pre>
        var datas:[String?] = {

            () -> [String?] in

            var dataSources:[String?] = [String?]()

            for i:Int in 0...5 {

                    dataSources.append(String.init(format: "第%ld个", i))
            }

            return  dataSources
        }()
    </pre>

    <p class="smallTitle" id="error1">
        <b>Property 'self.backgroundLabBgColor' not initialized at super.init - Delegate</b></p>
    <p class="contents">解决:将backgroundLabBgColor设置为optional:<a href="https://stackoverflow.com/questions/36635896/property-self-mydelegate-not-initialized-at-super-init-delegate">stackoverflow</a></p>

    <p class="smallTitle" id="closure">
        <b>swift中的闭包</b>
    </p>
    <pre>
        简单实例:
        声明:
            // 更改开关状态
            typealias ChangeSwiStateClosure = (Bool?)->(Void)
            var changeSwiStateClosure:ChangeSwiStateClosure?

            // MARK: - 开关事件
            func changeSwiState(swi:UISwitch) -> Void {

                changeSwiStateClosure!(swi.isOn)
            }

        调用:
            // 切换消息推送开关状态
            cell?.changeSwiStateClosure = {(state:Bool?) ->Void in

                // 网络更改消息推送开关状态
                self.changeMsgPushStateByNet(Switch: state, GuideId: userInfoModel.guideId, AccessToken: userInfoModel.accessToken)
            }
    </pre>

    <p class="contents" id="setget">
        <b>swift中的set与get</b>
    </p>
    <pre>
        当调用set方法的时候，系统会有一个newValue，
        将newVaule赋值给我们定义的变量，然后从get方法里面返回去。

        //定义一个变量
        var _a:String?

        var a:String?{

            set{

                _a = newValue
            }

            <b>//如果只从写get方法，会默认为readOnly</b>
            get{

                return _a
            }
        }

    </pre>
    <p class="contents">
        <b>另外:willSet和didSet这两个特性来监视属性的除初始化之外的属性值变化
            和OC相比较，我们可以在didSet里面执行一些改变UI的操作。
        </b>
    </p>
    <pre>

        var _a:String?

        var a:String?{

            <b>如果实现willSet观察，则将传递一个新的常量属性值，如果没有为其指定名称，则又默认名称“newValue”
                相似的，如果实现didSet观察，将传递旧的常量属性值，你可以为其指定名称，否则默认为“oldValue”</b>
            willSet{

                print("willSet = \(String(describing: newValue))")
            }

            <b>//设置指定名称</b>
            willSet(nnewValue){

                print("willSet = \(a ?? 0)") //willSet = 0
                print("nnew = \(nnewValue ?? 0)") //nnew = 11

            }

            <b>//如果在didSet里面给这个值再重新赋值，那么最终值是这个新值</b>
            didSet{

                print("didSet = \(String(describing: a))") //didSet = 11
                print("old = \(oldValue ?? 0)") //old = 0

                a = "hehe"
            }
        }

        scratchCard.a = 11
        print("a = \(scratchCard.a ?? 0)")

        输出:
        willSet = Optional("haha")
        didSet = Optional("haha")
        a = Optional("hehe")
    </pre>

    <br>


</div>

</body>
</html>