<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Swift那些搞过却又容易忘记的东东</title>
    <link rel="icon" href="../../../Source/icon-img.jpeg">
    <link rel="stylesheet" href="../../../CSS/ArticleDetail.css">
    <link rel="stylesheet" href="../../../Vendor/bootstrap-3.3.7-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>

<div class="labels">

    <span class="label label-success">swiftSwift那些搞过却又容易忘记的东东</span>
</div>

<div class="contentBgDiv">
    <p class="title">Swift那些搞过却又容易忘记的东东</p>
    <hr>

    <ul>
        <li><a href="http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/Introduction.shtml">The Swift Programming Language 中文版</a> </li>
        <li><a href="https://swiftdoc.org/">Swift源库文档</a></li>
        <li><a href="https://github.com/apple/swift">Swift源码</a></li>
        <li><a href="https://blog.csdn.net/youshaoduo/article/details/77967391">Swift4新特性参考链接</a> </li>
        <li><a href="#mark">swift中的mark</a> </li>
        <li><a href="#swift">swift 调用oc库</a> </li>
        <li><a href="#swiftInOc">oc工程使用swift库</a></li>
        <li><a href="#try">call can throw but is mot marked with try...</a> </li>
        <li><a href="#ocInSwift">swift项目中使用oc框架不提示方法</a> </li>
        <li><a href="#stringTransfer">关于变量类型</a> </li>
        <li><a href="#class">获取对象类型</a> </li>
        <li><a href="#after">swift的延时操作</a> </li>
        <li><a href="#mean">$0、$1的实际含义</a> </li>
        <li><a href="#lazy">swift中的数组与懒加载</a> </li>
        <li><a href="#error1">Property 'self.backgroundLabBgColor' not initialized at super.init - Delegate</a> </li>
        <li><a href="#objc">@objc,@nonobjc与@objcMembers</a> </li>
        <li><a href="#closure">swift中的闭包</a> </li>
        <li><a href="#setget">swift中的set与get</a> </li>
        <li><a href="#range">swift中的Range</a> </li>
        <li><a href="#pi">swift中的M_PI</a> </li>
        <li><a href="#weakStrongDanceInSwift">weak-Strong-In-Swift</a></li>
        <li><a href="#AnyAnyObjectAnyClass">Any 与 AnyObject AnyClass的区别</a></li>
        <li><a href="#as">Swift中as, as!, as? 的区别</a> </li>
        <li><a href="#Optional">Swift中的Optional</a> </li>
        <li><a href="#ClassOrStruct">Swift中的Class与Struct</a> </li>
        <li><a href="#SwitchInSwift">Swift中的Switch</a></li>
        <li><a href="#SearchAddressInSwift">Swift4查看对象地址</a></li>
        <li><a href="#Int">Swift中的Int,Int8,Int16,Int32,Int64</a></li>
        <li><a href="#genericClass">Swift中的泛型</a></li>
        <li><a href="#typealiasAndassociatedtype">Swift中typealias与associatedtype的区别</a></li>
        <li><a href="#PATs">Swift中的PATs</a></li>
        <li><a href="#ArrayInSwift">Swift中的数组</a></li>
        <li><a href="#arrFilter">给Array扩展一个自定义的过滤器</a></li>
        <li><a href="#dicFilter">给Dictionary添加一个过滤器</a></li>
        <li><a href="#arrReduce">给Array添加自定义reduce</a></li>
        <li><a href="#dicReduce">给Dictionary添加自定义reduce</a> </li>
        <li><a href="#arrMap">给Array添加自定义map</a></li>
        <li><a href="#dicMap">给Dictionary添加自定义map</a> </li>
        <li><a href="#swiftVersion">判断Swift版本</a> </li>
        <li><a href="#discardableResult">使用@discardableResult来忽略函数返回值</a> </li>
        <li><a href="#defer">Swift中的defer(延迟执行)</a> </li>
    </ul>

    <p class="smallTitle" id="swift"><b>swift 调用oc库</b></p>


    <p class="contents">
        1.、swift工程里新建Header file, 名称：项目名称-Bridging-Header.h
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-28538c944470898a.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-28538c944470898a.png?imageMogr2/auto-orient/strip"></a>

    <p class="contents">
        2、设置路径 target -> building settings -> swift compiler -> objective-c bridging header
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-219154da7df8daaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-219154da7df8daaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg"></a>


    <p class="contents">
        3、导入库 注意导入方式
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-cacc0ac39568debc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-cacc0ac39568debc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg"></a>

    <p class="smallTitle" id="swiftInOc"><b>oc工程使用swift库</b></p>

    <br>

    <p class="contents">
        在需要使用的地方添加：项目名称-Swift.h
    </p>
    <p class="contents">如果oc中调用不了swift方法,请在前面加上@objc</p>
    <p class="contents">原因:</p>
    <pre>
            Objective-C和Swift在底层使用的是两套完全不同的机制，Cocoa中的Objective-C对象是基于运行时的，
        它从骨子里遵循了KVC（Key-Value Coding，通过类似字典的方式存储对象信息）以及动态派发
        （Dynamic Dispatch，在运行调用时再决定实际调用的具体实现）。

            而Swift为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。
        也就是说，Swift类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，
        而可以直接使用。

            显而易见，这带来的问题是如果我们要使用Objective-C的代码或者特性来调用纯Swift的类型时候，
        我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在Swift类型文件中，
        我们可以将需要暴露给Objective-C使用的任何地方（包括类，属性和方法等）的声明前面加上
        @objc修饰符。注意这个步骤只需要对那些不是继承自NSObject的类型进行，
        如果你用Swift写的class是继承自NSObject的话，Swift会默认自动为所有的非private的类和成员加上@objc。
        这就是说，对一个NSObject的子类，你只需要导入相应的头文件就可以在Objective-C里使用这个类了。

            添加@objc修饰符并不意味着这个方法或者属性会变成动态派发，Swift依然可能会将其优化为静态调用。
        如果你需要和Objective-C里动态调用时相同的运行时特性的话，你需要使用的修饰符是dynamic。
        一般情况下在做App开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的
        "黑魔法" 的时候，我们就需要用到dynamic修饰符了。
    </pre>

    <p class="contents" id="objc"><b>@objc,@nonobjc,@objcMembers</b></p>
    <pre>
          1，过去的情况（Swift3）
        （1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。
            在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。
        （2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。
        class MyClass: NSObject {
            func print() { } // 包含隐式的 @objc
            func show() { } // 包含隐式的 @objc
        }
        （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。

        2，现在的情况（Swift4）
        （1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况：
            覆盖父类的 Objective-C 方法
            符合一个 Objective-C 的协议

        （2）大多数地方必须手工显示地加上 @objc。
        class MyClass: NSObject {
            @objc func print() { } //显示的加上 @objc
            @objc func show() { } //显示的加上 @objc
        }

        （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。
        @objcMembers
        class MyClass: NSObject {
            func print() { } //包含隐式的 @objc
            func show() { } //包含隐式的 @objc
        }

        extension MyClass {
            func baz() { } //包含隐式的 @objc
        }

        （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。
        class SwiftClass { }

        @objc extension SwiftClass {
            func foo() { } //包含隐式的 @objc
            func bar() { } //包含隐式的 @objc
        }

        （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。
        @objcMembers
        class MyClass : NSObject {
            func wibble() { } //包含隐式的 @objc
        }

        @nonobjc extension MyClass {
            func wobble() { } //不会包含隐式的 @objc
        }

    </pre>

    <p class="smallTitle" id="try"><b>call can throw but is mot marked with try...</b></p>

    <br>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-74e7b9d11c100885.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-74e7b9d11c100885.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">错误示意图1</p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-5d55359915853406.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-5d55359915853406.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">没有使用try.png</p>

    <p class="contents">
        <b>解决:</b>
    </p>

    <a target="_blank"
       href="http://upload-images.jianshu.io/upload_images/3251504-272f9efe48bb346a.png?imageMogr2/auto-orient/strip"><img
            src="http://upload-images.jianshu.io/upload_images/3251504-272f9efe48bb346a.png?imageMogr2/auto-orient/strip"></a>
    <p class="contents">do catch+try.png</p>

    <p class="smallTitle" id="ocInSwift"><b>swift项目中使用oc框架不提示方法</b></p>

    <br>

    <p class="contents">
        在swift工程中使用oc框架时：正确在项目名-Bridging-Header里导入了框架，
        如#import &lt;KissXML/KissXML.h&gt;,#import &lt;XMLReader/XMLReader.h&gt;还是不提示方法，
        可以这样：
    </p>

    <div class="codeAero">

        <p class="contents">
            1.第一步首先删除 此目录下的这个文件夹：~/Library/Developer/Xcode/DerivedData<br><br>

            2.重启xcode试试，如果还不提示，删除此目录下的这个文件：~/Library/Caches/com.apple.dt.Xcode<br><br>

            3.重新运行xcode就好了<br><br>
        </p>
    </div>

    <p class="contents">
        如果还是没用：在使用的地方再导入一次，如：import XMLReader
    </p>

    <p class="smallTitle" id="stringTransfer"><b>关于变量类型</b></p>

    <br>

    <p class="contents">
        Striing -》int 需要使用NSString来过渡，toInt不行了 注意变量的类型可以很大程度提高编译速度 特别是类似a/b/c
    </p>

    <p class="contents">
        如：<br>
        print(NSString(string:s).intValue+1)<br>
    </p>

    <p class="smallTitle" id="class"><b>获取对象类型</b></p>
    <pre>
        1.
        静态变量 object_getClass(&lt;#T##obj: AnyObject!##AnyObject!#&gt;)
        tableView.register(object_getClass(UITableViewCell()), forCellReuseIdentifier: "hehe")

        2. 万物皆对象
        UITableViewCell.self
        Int.self
        1.self
    </pre>

    <p class="smallTitle" id="after"><b>swift的延时操作</b></p>
    <pre>
        //延时1秒执行
        let time: TimeInterval = 1.0
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) {
          //code
          print("1 秒后输出")
        }
    </pre>

    <p class="smallTitle" id="mean"><b>$0、$1的实际含义</b></p>
    <p class="contents">
        swift自动为闭包提供参数名缩写功能，可以直接通过$0和$1等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：
    </p>
    <pre>
        let nums = [3,7,90,1,2,3,4,5,6,7]

        let sortNums = nums.sorted(by: { (a, b) -> Bool in

            return a < b
        })

        let sortNums2 = nums.sorted(by: {$0 < $1})

        print("sortNums = \(sortNums)\nsortNums2=\(sortNums2)")
    </pre>
    <p class="contents">
        输出结果:
    </p>
    <pre>
        sortNums = [1, 2, 3, 3, 4, 5, 6, 7, 7, 90]
        sortNums2=[1, 2, 3, 3, 4, 5, 6, 7, 7, 90]
    </pre>

    <p class="smallTitle" id="mark"><b>swift中的mark</b></p>
    <pre>
        oc:#pragma mark -说明文字
        swift:  // MARK: - 说明文字,带分割线
                // MARK: 说明文字,不带分割线
    </pre>

    <p class="smallTitle" id="lazy"><b>swift中的数组与懒加载</b></p>
    <p class="contents">
        使用let修饰的数组是不可变数组:let array2 : [NSObject] = ["age", 18]<br>
        使用var修饰的数组是可变数组:var array1 : [String] = [String]()
    </p>
    <pre>
        var datas:[String?] = {

            () -> [String?] in

            var dataSources:[String?] = [String?]()

            for i:Int in 0...5 {

                    dataSources.append(String.init(format: "第%ld个", i))
            }

            return  dataSources
        }()
    </pre>

    <p class="smallTitle" id="error1">
        <b>Property 'self.backgroundLabBgColor' not initialized at super.init - Delegate</b></p>
    <p class="contents">
        <pre>
        解决:
            1.将backgroundLabBgColor设置为optional:<a href="https://stackoverflow.com/questions/36635896/property-self-mydelegate-not-initialized-at-super-init-delegate">stackoverflow</a>
            2.在init中初始化
        </pre>
    </p>

    <p class="smallTitle" id="closure">
        <b>swift中的闭包</b>
    </p>
    <pre>
        简单实例:
        声明:
            // 更改开关状态
            typealias ChangeSwiStateClosure = (Bool?)->(Void)
            var changeSwiStateClosure:ChangeSwiStateClosure?

            // MARK: - 开关事件
            func changeSwiState(swi:UISwitch) -> Void {

                changeSwiStateClosure!(swi.isOn)
            }

        调用:
            // 切换消息推送开关状态
            cell?.changeSwiStateClosure = {(state:Bool?) ->Void in

                // 网络更改消息推送开关状态
                self.changeMsgPushStateByNet(Switch: state, GuideId: userInfoModel.guideId, AccessToken: userInfoModel.accessToken)
            }
    </pre>

    <p class="contents" id="setget">
        <b>swift中的set与get</b>
    </p>
    <pre>
        当调用set方法的时候，系统会有一个newValue，
        将newVaule赋值给我们定义的变量，然后从get方法里面返回去。

        //定义一个变量
        var _a:String?

        var a:String?{

            set{

                _a = newValue
            }

            <b>//如果只从写get方法，会默认为readOnly</b>
            get{

                return _a
            }
        }

    </pre>
    <p class="contents">
        <b>另外:willSet和didSet这两个特性来监视属性的除初始化之外的属性值变化
            和OC相比较，我们可以在didSet里面执行一些改变UI的操作。
        </b>
    </p>
    <pre>

        var _a:String?

        var a:String?{

            <b>如果实现willSet观察，则将传递一个新的常量属性值，如果没有为其指定名称，则又默认名称“newValue”
                相似的，如果实现didSet观察，将传递旧的常量属性值，你可以为其指定名称，否则默认为“oldValue”</b>
            willSet{

                print("willSet = \(String(describing: newValue))")
            }

            <b>//设置指定名称</b>
            willSet(nnewValue){

                print("willSet = \(a ?? 0)") //willSet = 0
                print("nnew = \(nnewValue ?? 0)") //nnew = 11

            }

            <b>//如果在didSet里面给这个值再重新赋值，那么最终值是这个新值</b>
            didSet{

                print("didSet = \(String(describing: a))") //didSet = 11
                print("old = \(oldValue ?? 0)") //old = 0

                a = "hehe"
            }
        }

        scratchCard.a = 11
        print("a = \(scratchCard.a ?? 0)")

        输出:
        willSet = Optional("haha")
        didSet = Optional("haha")
        a = Optional("hehe")
    </pre>

    <p class="contents" id="range"><b>swift中的Range</b></p>
    <pre>

        //1...self.screenShotArr.count-1
        self.screenShotArr.removeSubrange(1...self.screenShotArr.count-1)
    </pre>
    <br>

    <p class="contents" id="pi"><b>swift中的M_PI</b></p>
    <pre>
        M_PI_4相当于:CGFloat.pi/4; Double.pi; Float.pi;
    </pre>

    <p class="contents" id="weakStrongDanceInSwift"><b>Weak-Strong-In-Swift</b></p>
    <pre>
        在OC中处理循环引用：
        弱引用一次:__weak typeof(self) weakSelf = self
        防止子线程中调用block可能存在self提前释放进行一次retain：__strong(可缺省 默认) typeof(self) strongSelf = self

        例子：
        __weak typeof(self) weakSelf = self;
        [self doSomeBlockJob:^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                ...
            }
        }];


        在Swift中处理闭包循环引用：
        弱引用一次,使用捕获列表[weak self]：
        self.closure = {[weak self]() in
            self.doSomeThing()

            //防止闭包在子线程调用时，存在提前释放的情况，进行一次判断:
            guard let `self` = self else {return}

            `self`.doSomeThing()
        }

        例子：
        @IBAction func toThird(_ sender: Any) {

            self.third.back = {[weak self]() in

                guard let `self` = self else {
                    return
                }

                `self`.test()
            }

            self.navigationController?.pushViewController(third, animated: true)
        }

    </pre>

    <p class="contents" id="AnyAnyObjectAnyClass"><b>Swift中Any与AnyObject、AnyClass的区别</b></p>
    <pre>
        1. 定义：
        AnyObject：可以代表任何class类型的实例；
        Any：可以代表任何类型，甚至包括方法(func)类型。

        2.
        public typealias Any = protocol<>
        public protocol AnyObject{}
        public typealias AnyClass = Swift.AnyObject.Type

        3.
        a.AnyObject是Any的子集
        b.所有用class关键字定义的对象就是AnyObject
        c.所有不是用class关键字定义的对象就不是AnyObject，而是Any
        d.AnyClass是AnyObject的别名, Any是一个空协议集合的别名, 一个任何类型都遵守的协议，AnyObject是一个没有声明任何成员的空协议
        e.Any和AnyObject都是协议而且，并且从Apple提供的注释中可以看出所有的type(类型)都隐式实现了Any协议，所有的class都隐式实现了AnyObject协议。

        例子：
        1.Any此处Alamofire请求的键值对值可以是任意值
        parameters = ["appId":"123456", "timestamp":203428394820,
                "version":"1.0", "appAuthToken":"7D8SF7D8VS8987D67687",
                "bizContent":["pageStart":1, "pageSize": "10","isTrue":true]] as [String : Any]

        2.AnyObject：由于value是JSON类型的实例，complicate(value as AnyObject)， 就是将value作为AnyObject传值出去
        typealias Complicate = (AnyObject) ->Void
        //请求回调
        var complicate : Complicate?

        func request(type:RequestType, URLString:String, parameters:[String : AnyObject], complicate:@escaping Complicate) -> Void {
                CK().maskShow()
                switch type {
                case .requestTypeGet:
                    Alamofire.request(URLString, method: .get, parameters: parameters, encoding: JSONEncoding.default, headers: nil)
                        .validate()
                        .responseJSON { response in
                            CK().dismissMask()

                            switch response.result{
                            case .success:
                                if let value = response.result.value{
                                    //把得到的JSON数据转为字典
                                    complicate(value as AnyObject)
                                }
                            case .failure: ()
                                DMCAlertCenter.default().postAlert(withMessage: "网络请求失败")
                                return
                            }
                    }

    </pre>

    <p class="contents" id="as"><b>Swift中as, as!, as? 的区别</b></p>
    <pre>

        1.as:仅当一个值的类型在运行时（runtime）和as模式右边的指定类型一致 - 或者是该类型的子类 - 的情况下，
        才会匹配这个值。如果匹配成功，被匹配的值的类型被转换成as模式左边指定的模式。
        class Father{}
        class son{}

        let s = son()
        s as Father


        2. as! 父类强转子类
        class Father{}
        class son{}

        let f = Father()
        //不加！编译报错 转换失败 会崩溃
        f as! son


        3. as? 转换失败返回nil
        class Father{}
        class son{}

        let f = Father()
        //不加！编译报错 转换失败 会返回nil
        f as？ son

        补充：变量声明时！与？的区别
        a. var a:Int? 可选类型 后边不一定有值 没赋值时返回nil  赋值时返回Optional(xx)
        b. var b:Int! 隐式拆包 表示后面一定不会nil  没赋值时返回none  赋值时返回some(xx)
        c. Int?与Int! 都额外需要1个字节来保存信息

        例子：
            var a:Int? = 1
            var b:Int! = 2

            print(a)
            print(b)

            print(MemoryLayout&lt;Int?&gt;.self)
            print(MemoryLayout&lt;Int!&gt;.self)

            print("size = \(MemoryLayout&lt;Int?&gt;.size) align = \(MemoryLayout&lt;Int?&gt;.alignment) stride= \(MemoryLayout&lt;Int?&gt;.stride)")
            print("size = \(MemoryLayout&lt;Int!&gt;.size) align = \(MemoryLayout&lt;Int!&gt;.alignment) stride= \(MemoryLayout&lt;Int!&gt;.stride)")

            //输出结果
            //没有赋值：
            nil
            none
            //赋值：
            Optional(1)
            some(2)
            MemoryLayout&lt;Optional&lt;Int&gt;&gt;
            MemoryLayout&lt;ImplicitlyUnwrappedOptional&lt;Int&gt;&gt;
            size = 9 align = 8 stride= 16
            size = 9 align = 8 stride= 16

    </pre>


    <p class="contents" id="Optional"><b>Swift中的Optional</b></p>
    <pre>

        OC中分为基本类型和引用类型， 基本类型如NSInteger, NSString
        Swift中一切都是对象 如1.description

        OC中可以向nil发送消息 Swift中这是严格不允许的 所以如何保证程序不向空指针调用方法 可选类型就产生了

        1.Optional本质：枚举
        public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible {
            case None
            case Some(Wrapped)

            <b>//这个构造方法的存在使得Int, Int?？, nil等都可以复制给类型为Int？的变量</b>
            public init(_ some: Wrapped)

            public func map&lt;U&gt;(_ transform: (Wrapped) throws -> U) rethrows -> U?
            public func flatMap&lt;U&gt;(_ transform: (Wrapped) throws -> U?) rethrows -> U?
        }

        2.Optional的嵌套
        let a: Int? = 1
        let b: Int?? = a
        let c: Int??? = b

        let a: Int? = 1
        let b: Int?? = a
        let c: Int??? = b

        //输出:
        a = Optional(1)
        b = Optional(Optional(1))
        c = Optional(Optional(Optional(1)))

        //使用fr v -R a/b/c查看内存构成
        (Swift.Optional&lt;Swift.Int&gt;) a = some {
          some = {
            _value = 1
          }
        }
        (Swift.Optional&lt;Swift.Optional&gt;Swift.Int&gt;&gt;) b = some {
          some = some {
            some = {
              _value = 1
            }
          }
        }
        (Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) c = some {
          some = some {
            some = some {
              some = {
                _value = 1
              }
            }
          }
        }

        3.那么问题来了：
            let a: Int? = nil
            let b: Int?? = a
            let c: Int??? = b
            let d: Int??? = nil

            //输出结果
            a = nil
            b = Optional(nil)
            c = Optional(Optional(nil))
            d = nil

            if let _ = b {
                print("b is not nil")
            }else{
                print("b is nil")
            }

            //输出结果： b is not nil

            var dict:[String:String?] = [:]

            //对应输出：
            [:]

            dict = ["key":"value"]
            dict["key"] = nil
            dict

            //对应输出：
            ["key": "value"]
            nil
            [:]

            dict = ["key":"value"]
            dict["key"] = Optional&lt;String&gt;.none
            dict

            //对应输出：
            ["key": "value"]
            nil
            ["key": nil]

            dict = ["key":"value"]
            dict["key"] = Optional&lt;Optional&lt;String&gt;&gt;.none  //双重Optional才置正确删除Dictionary中的元素
            dict["key"]
            dict

            //对应输出：
            ["key": "value"]
            nil
            nil
            [:]

            var s1:String? = nil
            dict = ["key":"value"]
            dict["key"] = s1
            dict["key"]
            dict

            //对应输出
            nil
            ["key":"value"]
            nil
            nil
            ["key":nil]

            var s2:String?? = nil    //双重Optional才置正确删除Dictionary中的元素
            dict = ["key":"value"]
            dict["key"] = s2
            dict["key"]
            dict

            //对应输出
            nil
            ["key":"value"]
            nil
            nil
            [:]

            //原因：查看赋值时Dictionary[index]源码：
            public subscript(key: Key) -> Value? {
              get {
                return _variantStorage.maybeGet(key)
              }
              set(newValue) {
                if let x = newValue {
                  // FIXME(performance): this loads and discards the old value.
                  _variantStorage.updateValue(x, forKey: key)
                }
                else {
                  // FIXME(performance): this loads and discards the old value.
                  removeValueForKey(key)
                }
              }
            }

            设置它的值，它接受的是一个 String? 类型的参数。
            而上边例子中的 value 类型为 String?，所以正常情况下它需要的是一个 String?? 类型的参数

            Dictionary和Array不同的是，[]用在Dictionary的时候，会返回一个Optional类型来确保这种形式的访问安全。因此访问不存在的key，并不会导致运行时错误。
            Swfit为Dictionary的索引查询操作，提供了optional保护。要么得到正确的结果，要么通过nil表示要查询的内容不存在。
    </pre>

    <p class="contents" id="ClassOrStruct"><b>Swift中的Class与Struct</b></p>
    <pre>
        Swift中有三大类型：class:引用类型reference Struct/Enum:值类型 value type

        区别:
        1. 初始化方法不同：
        struct ss1{

            var a:Int!
        }

        // struct可直接在构造函数中初始化property
        let sss1:ss1 = ss1(a: 1)

        class ss2{

            var a:Int?
        }

        // class不可直接在构造函数中初始化property
        let sss2:ss2 = ss2()
        sss2.a = 1

        2.struct更方便在LLDB中查看数据，class要求实现description

        3.变量赋值方式不同：
            struct是值拷贝，会copy一份给新的变量， class只是地址引用

            例子：
            let a = A(a: 1)
            let b = age

            print("a = \(Unmanaged.passUnretained(a as AnyObject).toOpaque())")
            print("b = \(Unmanaged.passUnretained(b as AnyObject).toOpaque())")

            let c = B()
            c.a = 1
            let d = c
            print("c = \(Unmanaged.passUnretained(c as AnyObject).toOpaque())")
            print("d = \(Unmanaged.passUnretained(d as AnyObject).toOpaque())")

            //输出:
            a = 0x000060c00004e040
            b = 0xb000000000000013
            c = 0x000060c00002a980
            d = 0x000060c00002a980

        4.struct中在实例初始化方法中需要加上mutating才能改变外部变量，class不用

        5.继承的区别

        6.struct比class轻量， struct变量保存在栈上，class变量保存在堆上，struct类型在编译时已经确定，class在运行时确定，
            因此struct能加快编译速度。

        7.安全性
            strcut是引用安全的，不采用引用计数

        8.内存泄露
            struct不存在因为循环引用导致的内存泄露问题

        9.线程安全
            struct是线程安全的

        10.OC与Swift的互相调用
            当你的项目是OC与Swift混编时，struct不能在OC中调用

        11.序列化
            Struct不能像类一样被序列化成NSData对象


    </pre>

    <p class="contents" id="SwitchInSwift"><b>Swift中的Switch</b></p>
    <pre>
        1.在Swift语言中的Switch中，你可以匹配数字，字符串，元组，字符区间等
        Swift中的Switch是不需要使用break语句的，因为其默认执行完匹配项就跳出Switch语句了

        例子：
        //匹配区间 比写if要好👌
        let a:(Int,Int) = (50,50)
        switch a {
            case (0..<50, 0..<50):
                print("0..<50")
            case (50..<100, 50..<100):
                print("50..<100")
            default:
                print(100)
        }

        2.Swift中的Switch语句，可以进行数值绑定，以及在case中使用where子句

            let a:String = "ABC"
            switch a {
                case let temp where temp > "A":

                    print("> A")
                case let temp where temp > "D":

                    print("> D")
                default:
                    print("default")
            }

        3.fallthrough:加了fallthrough后，会直接运行【紧跟的后一个】case或default语句，不论条件是否满足都会执行
            fallthrough和break可以依据两者的顺序可以相互打断执行

            var age = 1
            switch age {
            case 0..<10:
                print("小朋友")

                fallthrough
            case 10..<100:
                print("成年人")

                fallthrough
            default:
                print("")
            }

            //输出:
                小朋友
                成年人


    </pre>

    <p class="contents" id="SearchAddressInSwift"><b>Swift4查看对象地址</b></p>
    <pre>

        Swift的&操作和C语言不同，Swift不允许直接获取对象的指针，比如下面的代码就会编译不通过。
        var a:Int = 1
        &a

        //查询Swift中对象的地址
        Unmanaged.passUnretained(对象 as AnyObject).toOpaque()
    </pre>

    <p class="contents" id="Int"><b>Swift中的Int,Int8,Int16,Int32,Int64</b></p>
    <img src="../../../Source/swift/cswiftbasictype.png">
    <pre>
        Int16, 等于short, 占2个字节. -32768 32767
        Int32, 等于int, 占4个字节. -2147483648 2147483647
        Int64, 等于long, 占8个字节. -9223372036854775808 9223372036854775807
        Int8 ,占用1个字节
        Int的默认值是64bit 8字节
    </pre>


    <p class="contents" id="genericClass"><b>Swift中的泛型</b></p>
    <pre>

        <b>//交换两个数：</b>
        func exchange&lt;T&gt;(a:inout T, b:inout T) -> Void {

            let temp = a
            a = b
            b = temp
        }

        //类型参数:
        在上面的泛型函数例子中，占位符T是类型参数的一个例子，T代表只是一个占位符。
        类型参数指定并命名一个占位符类型，并用<>包裹，放在函数名后面。
        在编译器的时候已经确定参数类型

        <b>//数组泛型操作</b>
        public struct heap&lt;T&gt;{

            var items = [T]()

            mutating func push(element:T) -> Void {

                items.append(element)
            }
        }
        <b>//给泛型类型添加扩展</b>
        extension heap{

            func topItem() -> T {

                return (items.isEmpty ? nil : items[items.count-1])!
            }
        }

        //测试:
        var hp:heap = heap&lt;String&gt;()
        hp.push(element: "ssss")
        hp.push(element: "ddd")

        print(hp.topItem()) //输出：ddd

        <b>//泛型类型约束</b>
        //实例：数组中是否存在某个数，遵循了Equatable协议的对象才能用来判断是否相等
        func findIndex&lt;T:Equatable&gt;(arr:[T], t:T) -> Int? {

            for (index, value) in arr.enumerated(){

                if value == t{

                     return index
                }
            }

            return Optional.none
        }

        print(findIndex(arr: ["sss", "ddd", "ggg"], t: "ggg"))
        print(findIndex(arr: [1,2,3,4], t: 1))
        //输出：
        Optional(2)
        Optional(0)


         <b>//泛型的where语句</b>
        类型约束能够让我们为泛型类型添加一些约束和条件。为关联类型添加一些约束也是很有必要的。
        可以在参数列表中使用where子句来为关联类型添加约束。

        例子:
        //MARK: -判断两个数组是否一模一样
        func same&lt;c1:container, c2:container&gt;(container:c1, anotherContainer:c2) -> Bool where c1.itemType == c2.itemType, c1.itemType:Equatable {

            guard container.count == anotherContainer.count else {

                return false
            }

            for i in 0...container.count-1 {

            //c1.itemType:Equatable保证是可以比较的
            if container[i] == anotherContainer[i]
            {
                return false

            }

            return true
        }

    </pre>

    <p class="contents" id="typealiasAndassociatedtype"><b>Swift中typealias与associatedtype的区别</b></p>
    <pre>

        <b>1.typealias:</b>
            typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。
            使用的语法也很简单，使用typealias 关键字像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新的名字。

            例子：
            typealiad Success:(_ model:XXModel) -> (void)

            typealias 是单一的，也就是说你必须指定将某个特定的类型通过typealias赋值为新名字，而不能将整个泛型类型进行重命名。
            class Person&lt;T&gt; {}
            typealias Woker = Person
            typealias Worker&lt;T&gt; = Person&lt;T&gt;
            typealias Worker = Person&lt;WorkId&gt;

        <b>2.某个类型同时实现多个协议的组合时。我们可以使用&符号连接几个协议，然后给它们一个新的更符合上下文的名字，来增强代码可读性:</b>
            例子：
            protocol Cat {}
            protocol Dog {}
            typealias Pat = Cat & Dog

            例子：
            public protocol p1 {

                <b>//原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的。</b>
                <b>//给自定义的协议中添加extension,在extension中对可选方法进行默认实现,这样遵守协议的对象就可以不用实现可选方法.</b>
                associatedtype itemType1

                var item1:String?{get}

                mutating func log1()
            }

            public protocol p2 {

                associatedtype itemType2

                var item2:String?{get}

                mutating func log2()
            }

            extension p1{

                var item1:String?{
                    return item1
                }
            }

            extension p2{

                var item2:String?{
                    return item2
                }
            }

            struct class2:p1&p2 { //或者p1,p2 用逗号分开

                typealias itemType1 = String
                typealias itemType2 = String

                mutating func log1() {

                    print("log1")
                }

                mutating func log2() {

                    print("log2")
                }
            }

            //测试：
            var cls2:class2 = class2()
            cls2.log1()
            cls2.log2()

            //输出：
            log1
            log2

        <b id="PATs">2.associatedtype关联类型/Swift中的PATs:Protocols with Associated Types带有关联类型的协议</b>
            定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。
            你可以通过 associatedtype 关键字来指定关联类型。
            关联类型 使得swift更加的面向协议

            例子：
            public protocol container {

                //关联类型：用来声明一个抽象的协议 associatedtype
                associatedtype itemType //声明一个关联类型

                mutating func append(_ item:itemType)
                //协议需要{get} {get set}
                var count:Int{get}
                subscript(i:Int) ->itemType {get}
            }

            //实现该协议：
            struct genericStack&lt;T&gt; : container{

                //实现container
                typealias itemType = T

                mutating func append(_ item: T) {

                    items.append(item)
                }

                var count: Int{

                    get{
                        return self.items.count
                    }
                }

                subscript(i: Int) -> T {

                    return items[i] as T
                }
            }


    </pre>

    <p class="contents" id="ArrayInSwift"><b>Swift中的数组</b></p>
    <pre>

        var threeInts:Array&lt;Int&gt; = Array&lt;Int&gt;(repeating: 3, count: 3)

        //+法
        var sixInts:Array&lt;Int&gt; = threeInts+threeInts

        //值
        sixInts.last
        sixInts.first
        //下标
        sixInts.endIndex
        sixInts.startIndex
        sixInts[0]
        sixInts[0..<3] //subscript(_: Range&lt;Array&lt;Element&gt;.Index&gt;)
        //是否为空
        sixInts.isEmpty
        //数量
        sixInts.count
        //添加
        sixInts.append(7)
        sixInts.append(contentsOf: [1,2])
        sixInts += [10]
        sixInts.insert(20, at: 0)
        //删除
        sixInts.remove(at: 0)
        sixInts.removeFirst()
        sixInts.removeLast()
        sixInts.popLast()

        <b>//元素类型：</b>
        type(of: arr[1])

        <b>//数组的拷贝</b>
        var a = [1,2,3]
        var b = a

        print(getBufferAddress(of: a), getBufferAddress(of: b))
        print("a = \(a) b = \(b)")

        b += [4]

        print(getBufferAddress(of: a), getBufferAddress(of: b))
        print("a = \(a) b = \(b)")

        //输出：
        Optional(0x000060800026ad60) Optional(0x000060800026ad60)
        a = [1, 2, 3] b = [1, 2, 3]
        Optional(0x000060800026ad60) Optional(0x0000604000281bf0)
        a = [1, 2, 3] b = [1, 2, 3, 4]

        func getBufferAddress&lt;T&gt;(of array:[T]) -> String {

            //withUnsafeBufferPointer是Array的一个方法，它可以把保存Array内容的地址，传递给它的closure参数。在我们的例子里，这个closure只是把Array的地址，变成了一个String对象。
            return array.withUnsafeBufferPointer({ (buffer)  in

                return String(describing: buffer.baseAddress)
             })
        }

        <b>//可见，数组的拷贝只在拷贝的b赋值之后才会被重新分配内存地址。</b>

        <b>//数组的遍历：</b>
        arr.forEach { (element) in


        }

        for (index, value) in arr.enumerated(){


        }

        var iterator = arr.makeIterator()
        while let element = iterator.next(){
            print(element)
        }

        let array = arr.filter { (element) -> Bool in

            return element > 5
        }


        let arr1 = [[1,2,4],[1,2]].map { (element) -> [Int] in

            var ele:[Int] = [Int]()

            for a in element{

                guard a%2 == 0 else {continue}

                ele.append(a)
            }

            return ele
        }
        //arr1 = [[2, 4], [2]]

        let arr2 = [[1,2,4],[1,2]].flatMap { (element) -> [Int] in

            var ele:[Int] = [Int]()

            for a in element{

                guard a%2 == 0 else {continue}

                ele.append(a)
            }

            return ele
        }
        //arr2 = [1,2,4,1,2]

        let sum = [1,2,4].reduce(0) { (sum, element) -> Int in

            return sum+element
        }
        //简化：let sum = [1,2,4].reduce(0){$0+$1}
        //再简化：let sum = [1,2,4].reduce(0, +)
        //7

        //arr2 = [2, 4, 2]


        <b id="arrFilter">//给Array扩展一个自定义的过滤器</b>
        extension Array{

            func myFilter(_ predicate:(Element)->(Bool)) -> [Element] {

                var temp:[Element] = []

                for value in self where predicate(value) {

                    temp.append(value)
                }

                return temp
            }
        }

        //调用：
        var arr = [1,2,4].myFilter { (element) -> (Bool) in

            return (element%2 == 0)
        }
        //arr = [2,4]

        <b id="arrMap">给Array扩展自定义map</b>
        extension Array{

            func myMap&lt;T&gt;(_ predicate:(Element)->T) -> [T] {

                var temp:[T] = [T]()

                for value in self {

                    let t:T = predicate(value)
                    temp.append(t)
                }

                return temp
            }
        }

        //测试:
        let arr = [1,2,4].myMap { (element) -> Int in

            return element+10
        }
        //[11,12,14]

        <b id="dicFilter">//给Dictionary添加一个过滤器</b>
        extension Dictionary{

            func myFilter(_ predicate:(Element) ->(Bool)) ->[String:Any] {

                var kv:[String:Any] = [String:Any]()

                for value in self where predicate(value){

                    <b>字典添加数据</b>
                    kv.updateValue(value.value, forKey: value.key as! String)
                }

                return kv
            }
        }

        //测试:
        var dic = ["1":1,"2":2].myFilter { (element) -> (Bool) in

            return element.value >= 2
        }
        //["2": 2]

        <b id="arrReduce">//给Array添加自定义Reduce</b>
        extension Dictionary{

            func myReduce&lt;T&gt;(_ initial:T, _ next:(T,Element)->T) -> T {

                var temp = initial

                for value in self {

                    temp = next(temp, value)
                }

                return temp
            }
        }

        //测试：
        let arr2 = [1,2,3,4].myReduce(0) { (sum, ele) -> Int in

            return sum+ele
        }
        //10

        <b id="dicReduce">//给dic添加自定义Reduce</b>
        extension Dictionary{

            func myReduce&lt;T&gt;(_ initial:T, _ next:(T, Element)->T) -> T {

                var temp:T = initial

                for value in self{

                    temp = next(temp, value)
                }

                return temp
            }
        }

        //测试：
        let arr2 = ["1":1, "2":2].myReduce(0) { (sum, ele) -> Int in

            return sum+ele
        }
        //3

        <b id="dicMap">//给dic添加自定义map</b>
        extension Dictionary{

            func myMap&lt;T&gt;(_ predicate:(Element)->(T)) -> [String:T] {

                var temp:[String:T] = [String:T]()

                for value in self {

                    let t:T = predicate(value)
                    temp.updateValue(t, forKey: value.key as! String)
                }

                return temp
            }
        }

        //测试：
        let dic = ["1":1,"2":2].myMap { (element) -> (Int) in

            return element.value+10
        }
        //["2": 12, "1": 11]

    </pre>
    
    <p class="smallTitle" id="swiftVersion"><b>判断Swift版本</b></p>
    <img src="../../../Source/swift/1.png">

    <p class="smallTitle" id="discardableResult"><b>使用@discardableResult来忽略函数返回值</b></p>
    <pre>
        extension ViewController{

            @discardableResult
            func sss() -> String {
                return "ssss"
            }
        }

        sss() //没有⚠️

        或者使用通配符：
        _ = sss()
    </pre>

    <p class="smallTitle" id="defer">Swift中的defer(延迟执行)</p>
    <div class="contents">
        <p>
            Swift中的异常处理try-catch-finally，finally不管有没有异常都会执行，defer也是如此，而且更加方便。
            简单来说，defer修饰的代码块都会在return之前调用，之一实在return之前，写在之后就没用了。
        </p>
        <pre>
            <b>例子:</b>
                func foo() {
                    print("1")
                    defer {
                        print("6")
                    }
                    print("2")
                    defer {
                        print("5")
                    }
                    print("3")
                    defer {
                        print("4")
                    }
                }

            foo()

            //输出1，2，3，4，5，6
            //多个 defer 的顺序是像栈一样倒着执行的：每遇到一个 defer 就像压进一个栈里，到结束的时候，后进栈的先执行。

            <b>常见使用场合：1.在获取到api数据的时候，加载视图的移除操作可以写在这里面；2.清除内存等一些重置工作可以写在这里面；
            </b>
        </pre>
    </div>


</div>

</body>
</html>